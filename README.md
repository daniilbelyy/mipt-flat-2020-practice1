
Идея алгоритма: будем идти по обратной польской нотации, вычисляя, какие количества символа мы можем получить на конкретном куске. Поскольку нас интересует кратность числу k, то будем искать не конкретно количества символа, тк это количество может быть бесконечным, а конкретно остатки деления на k. Если финальный кусок (всё выражение) имеет в своём наличии остаток 0 (тоесть можно подобрать слово, кол символа в котором кратно k), то ответ YES, иначе NO. Определим правила разбора: если встречаем символ не x, то кладём в стек множество, cостоящее из 0 (дейтсвительно , слово b или 1 содержит 0 a-шек, И если искомый символ a, то такое слово удовлетворяет нашему условию). Если встречаем символ x, то кладём в стек множество , состоящее из 1. Если встречаем ., То берём из стека 2 множества (если так сделать нельзя то выводим ERROR), и кладём в стек множество всевозможных чисел, равных (a + b) % k, где а - число из первого ножества, b - число из второго. если встречаем +, то берём 2 множества из стека и кладём в него объединение этих 2 множеств. Если же встречаем *, то берём из стека 1 множество, и делаем следующее: вычисляем общий НОД всех чисел попарно ( получаем НОД первых 2, полуаем следующий НОД как НОД предыдущего нода и нового числа), и кладём в множество все возможные чилса вида НОД * 0, НОД * 1 и тд по модулю k. Естественно 0 не учавствует в НОДах. Когда остаётся 1 кусок, то смотрим в нём наличие 0, если он есть то ответ YES, иначе NO.
Корректность : если встречается ., то очевидно , что суммарное кол числа x у всего куска является суммой кол x в первом куске и кол x во втором. В случае + суммарное кол x куска равно либо кол первого, либо кол второго. В случае * же эффект как от нескольких . (может и нуля .), и является всевозможными суммами, по теории вычетов алгоритм корректен. 
Асимптотика: достаём и кладём множества в среднем за O(1), Тк используем unordered_set, . работает за mn - где m - размер первого множества, а n - размер 2. + За m + n, * за nk, длина любого куска < длина нотации => L(nm + nk).

Белый Даниил Б05-921
