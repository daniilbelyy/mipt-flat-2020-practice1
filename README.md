Идея алгоритма: будем идти по обратной польской нотации, вычисляя, какие количества символа мы можем получить на конкретном куске. Поскольку нас интересует кратность числу k, то будем искать не конкретно количества символа, тк это количество может быть бесконечным, а конкретно остатки деления на k. Если финальный кусок (всё выражение) имеет в своём наличии остаток 0 (тоесть можно подобрать слово, кол символа в котором кратно k), то ответ YES, иначе NO. Определим правила разбора: если встречаем символ не x, то кладём в стек множество, cостоящее из 0 (дейтсвительно , слово b или 1 содержит 0 a-шек, И если искомый символ a, то такое слово удовлетворяет нашему условию). Если встречаем символ x, то кладём в стек множество , состоящее из 1. Если встречаем ., То берём из стека 2 множества (если так сделать нельзя то выводим ERROR), и кладём в стек множество всевозможных чисел, равных (a + b) % k, где а - число из первого ножества, b - число из второго. если встречаем +, то берём 2 множества из стека и кладём в него объединение этих 2 множеств.
Если же встречаем *, то берём из стека 1 множество, и делаем следующее: если в множестве есть 2 числа, чей НОД = 1, то кладём в стек множество, состоящее из всех неотрицательных чисел < k (0, 1, 2, ..., k-1), если же в множестве нет такой пары, то берём наименьшее из чисел, не равное 0, назовём его q, и кладём в стек множество, cостоящее из чисел вида q * 0 % k, q * 1 % k, q * 2 % k, b тд. 
Корректность : если встречается ., то очевидно , что суммарное кол числа x у всего куска является суммой кол x в первом куске и кол x во втором. В случае + суммарное кол x куска равно либо кол первого, либо кол второго. В  случае * же эффект как от нескольких . (может и нуля .), и является всевозможными суммами, по теории вычитов возможны 2 случая: либо есть два числа a и b с НОД 1, и тогда можно получить любое число > ab - a - b => любой остаток от деления на k , либо же нет таких 2 чисел и все остатки - это остатки от всевозможных сумм минимальных элементов отличных от 0. 
Асимптотика: достаём и кладём множества в среднем за O(1), Тк используем unordered_set, . работает за mn - где m - размер первого множества, а n - размер 2. + За m + n, * за nk, длина любого куска < длина нотации => L(nm + nk).
